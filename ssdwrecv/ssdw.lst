     1                                  ; -----------------------------------------------------------------------
     2                                  ;  Copyright (C) 2023  Matt Westveld
     3                                  ;
     4                                  ;  This program is free software: you can redistribute it and/or modify
     5                                  ;  it under the terms of the GNU General Public License as published by
     6                                  ;  the Free Software Foundation, either version 3 of the License, or
     7                                  ;  (at your option) any later version.
     8                                  ;
     9                                  ;  This program is distributed in the hope that it will be useful,
    10                                  ;  but WITHOUT ANY WARRANTY; without even the implied warranty of
    11                                  ;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    12                                  ;  GNU General Public License for more details.
    13                                  ;
    14                                  ;  You should have received a copy of the GNU General Public License
    15                                  ;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
    16                                  ;
    17                                  ; -----------------------------------------------------------------------
    18                                  
    19                                  [map symbols ssdw.map]
    20                                  
    21                                  bits 16
    22                                  cpu 8086
    23                                  
    24                                  args_len	equ		0x80	; location of argument data length
    25                                  args_data	equ		0x81	; location of argument data 
    26                                  
    27                                  cmd_recv_sector equ 	0x00		; cmd: 00, sector # (0-17) , NA
    28                                  cmd_write_track equ 	0x01		; cmd: 01, drive #, track #, head #, sectors to write
    29                                  cmd_reset 		equ 	0x08		; cmd: 08, drive #
    30                                  cmd_quit 		equ 	0xFF		; cmd: FF, NA
    31                                  
    32                                  org 100h
    33                                  section .text 
    34                                  
    35                                  	; check ourselves before we wreck ourselves
    36 00000000 8B0E[3200]              	mov cx, [file_len]
    37 00000004 BE0001                  	mov si, 0x100
    38 00000007 E8B202                  	call compute_checksum
    39 0000000A 3B1E[3400]              	cmp bx, [file_cksum]
    40 0000000E 7409                    	je start
    41 00000010 BE[1600]                	mov si, bad_cksum_text
    42 00000013 E88C00                  	call printz
    43 00000016 E93B03                  	jmp bye
    44                                  
    45                                  start:
    46 00000019 E9FA00                  	jmp get_args
    47                                  init:
    48 0000001C E8FE02                  	call init_com
    49                                  ; -----------------------------------------------------------------------		
    50                                  get_frame:
    51                                  	; wait for our frame startcode
    52 0000001F E8B302                  	call recv_byte
    53 00000022 3A06[2800]              	cmp al, [startcode]
    54 00000026 75F7                    	jne get_frame
    55                                  
    56                                  	; next 2 bytes are the length of the cmd + data (if any)
    57 00000028 E8AA02                  	call recv_byte
    58 0000002B A2[2900]                	mov [datalen], al
    59 0000002E E8A402                  	call recv_byte
    60 00000031 A2[2A00]                	mov [datalen + 1], al
    61 00000034 8B0E[2900]              	mov cx, [datalen]
    62 00000038 81F90802                	cmp cx, 0x208
    63 0000003C 77E1                    	ja get_frame	; too big, something wrong, start over
    64                                  
    65                                  	; grab the data
    66 0000003E BB[0000]                	mov bx, cmdbuf
    67                                  .dataloop:
    68 00000041 E89102                  	call recv_byte
    69 00000044 8807                    	mov [bx],al
    70 00000046 43                      	inc bx
    71 00000047 E2F8                    	loop .dataloop
    72                                  
    73                                  	; grab the checksum
    74 00000049 E88902                  	call recv_byte
    75 0000004C A2[2B00]                	mov [chksum],al
    76 0000004F E88302                  	call recv_byte
    77 00000052 A2[2C00]                	mov [chksum+1],al	
    78                                  
    79 00000055 BE[0000]                	mov si, cmdbuf
    80 00000058 8B0E[2900]              	mov cx, [datalen]
    81 0000005C E85D02                  	call compute_checksum
    82                                  
    83 0000005F 3B1E[2B00]              	cmp bx, [chksum]
    84                                  	; if checksum match:
    85                                  	; 	send startcode + 2
    86                                  	; 	startcode XOR= 1
    87                                  	; 	process cmd
    88                                  
    89 00000063 751E                    	jne badchk
    90 00000065 B02E                    	mov al, '.'	; print period
    91 00000067 E82B00                  	call printc
    92 0000006A A0[2800]                	mov al, [startcode]
    93 0000006D 0402                    	add al, 2
    94 0000006F E89202                  	call send_byte
    95 00000072 A0[2800]                	mov al, [startcode]
    96 00000075 3401                    	xor al, 1
    97 00000077 A2[2800]                	mov [startcode], al
    98 0000007A B80000                  	mov ax,0
    99 0000007D E89001                  	call proc_cmd
   100 00000080 E99CFF                  	jmp get_frame
   101                                  
   102                                  	; otherwise:
   103                                  	; 	send startcode XOR=1 + 2
   104                                  	; 	loop back and wait again
   105                                  
   106                                  badchk:	
   107 00000083 B078                    	mov al, 'x'		; print x
   108 00000085 E80D00                  	call printc
   109 00000088 A0[2800]                	mov al, [startcode]
   110 0000008B 3401                    	xor al, 1
   111 0000008D 0402                    	add al, 2
   112 0000008F E87202                  	call send_byte
   113 00000092 E98AFF                  	jmp get_frame
   114                                  
   115                                  %include "print.asm"
     1                              <1> ;=========================================================================
     2                              <1> ; Pulled on 2023/2/8 from bios.asm here:
     3                              <1> ; https://github.com/skiselev/8088_bios
     4                              <1> ; Mods: 
     5                              <1> ; pull out just the print functions
     6                              <1> ; print renamed -> printz
     7                              <1> ; add printc
     8                              <1> ;-------------------------------------------------------------------------
     9                              <1> ;
    10                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    11                              <1> ;
    12                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    13                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                              <1> ;
    15                              <1> ; This program is free software: you can redistribute it and/or modify
    16                              <1> ; it under the terms of the GNU General Public License as published by
    17                              <1> ; the Free Software Foundation, either version 3 of the License, or
    18                              <1> ; (at your option) any later version.
    19                              <1> ;
    20                              <1> ; This program is distributed in the hope that it will be useful,
    21                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                              <1> ; GNU General Public License for more details.
    24                              <1> ;
    25                              <1> ; You should have received a copy of the GNU General Public License
    26                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                              <1> ;
    28                              <1> ;=========================================================================
    29                              <1> 
    30                              <1> ;=========================================================================
    31                              <1> ; print - print one char to the console
    32                              <1> ; Input:
    33                              <1> ;	AL - char to print
    34                              <1> ; Output:
    35                              <1> ;	none
    36                              <1> ;-------------------------------------------------------------------------
    37                              <1> printc:
    38 00000095 9C                  <1> 	pushf
    39 00000096 50                  <1> 	push	ax
    40 00000097 53                  <1> 	push	bx
    41 00000098 B40E                <1> 	mov	ah,0Eh
    42 0000009A B30F                <1> 	mov	bl,0Fh
    43 0000009C CD10                <1> 	int	10h
    44 0000009E 5B                  <1> 	pop	bx
    45 0000009F 58                  <1> 	pop	ax
    46 000000A0 9D                  <1> 	popf
    47 000000A1 C3                  <1> 	ret
    48                              <1> 
    49                              <1> ;=========================================================================
    50                              <1> ; printz - print ASCIIZ string to the console
    51                              <1> ; Input:
    52                              <1> ;	CS:SI - pointer to string to print
    53                              <1> ; Output:
    54                              <1> ;	none
    55                              <1> ;-------------------------------------------------------------------------
    56                              <1> printz:
    57 000000A2 9C                  <1> 	pushf
    58 000000A3 50                  <1> 	push	ax
    59 000000A4 53                  <1> 	push	bx
    60 000000A5 56                  <1> 	push	si
    61 000000A6 1E                  <1> 	push	ds
    62 000000A7 0E                  <1> 	push	cs
    63 000000A8 1F                  <1> 	pop	ds
    64 000000A9 FC                  <1> 	cld
    65                              <1> .1:
    66 000000AA AC                  <1> 	lodsb
    67 000000AB 08C0                <1> 	or	al,al
    68 000000AD 7409                <1> 	jz	.exit
    69 000000AF B40E                <1> 	mov	ah,0Eh
    70 000000B1 B30F                <1> 	mov	bl,0Fh
    71 000000B3 CD10                <1> 	int	10h
    72 000000B5 E9F2FF              <1> 	jmp	.1
    73                              <1> .exit:
    74 000000B8 1F                  <1> 	pop	ds
    75 000000B9 5E                  <1> 	pop	si
    76 000000BA 5B                  <1> 	pop	bx
    77 000000BB 58                  <1> 	pop	ax
    78 000000BC 9D                  <1> 	popf
    79 000000BD C3                  <1> 	ret
    80                              <1> 
    81                              <1> ;=========================================================================
    82                              <1> ; print_hex - print 16-bit number in hexadecimal
    83                              <1> ; Input:
    84                              <1> ;	AX - number to print
    85                              <1> ; Output:
    86                              <1> ;	none
    87                              <1> ;-------------------------------------------------------------------------
    88                              <1> print_hex:
    89 000000BE 86C4                <1> 	xchg	al,ah
    90 000000C0 E80600              <1> 	call	print_byte		; print the upper byte
    91 000000C3 86C4                <1> 	xchg	al,ah
    92 000000C5 E80100              <1> 	call	print_byte		; print the lower byte
    93 000000C8 C3                  <1> 	ret
    94                              <1> 
    95                              <1> ;=========================================================================
    96                              <1> ; print_byte - print a byte in hexadecimal
    97                              <1> ; Input:
    98                              <1> ;	AL - byte to print
    99                              <1> ; Output:
   100                              <1> ;	none
   101                              <1> ;-------------------------------------------------------------------------
   102                              <1> print_byte:
   103 000000C9 D0C0                <1> 	rol	al,1
   104 000000CB D0C0                <1> 	rol	al,1
   105 000000CD D0C0                <1> 	rol	al,1
   106 000000CF D0C0                <1> 	rol	al,1
   107 000000D1 E82D00              <1> 	call	print_digit
   108 000000D4 D0C0                <1> 	rol	al,1
   109 000000D6 D0C0                <1> 	rol	al,1
   110 000000D8 D0C0                <1> 	rol	al,1
   111 000000DA D0C0                <1> 	rol	al,1
   112 000000DC E82200              <1> 	call	print_digit
   113 000000DF C3                  <1> 	ret
   114                              <1> 
   115                              <1> ;=========================================================================
   116                              <1> ; print_dec - print 16-bit number in decimal
   117                              <1> ; Input:
   118                              <1> ;	AX - number to print
   119                              <1> ; Output:
   120                              <1> ;	none
   121                              <1> ;-------------------------------------------------------------------------
   122                              <1> print_dec:
   123 000000E0 50                  <1> 	push	ax
   124 000000E1 51                  <1> 	push	cx
   125 000000E2 52                  <1> 	push	dx
   126 000000E3 B90A00              <1> 	mov	cx,10		; base = 10
   127 000000E6 E80400              <1> 	call	.print_rec
   128 000000E9 5A                  <1> 	pop	dx
   129 000000EA 59                  <1> 	pop	cx
   130 000000EB 58                  <1> 	pop	ax
   131 000000EC C3                  <1> 	ret
   132                              <1> 
   133                              <1> .print_rec:			; print all digits recursively
   134 000000ED 52                  <1> 	push	dx
   135 000000EE 31D2                <1> 	xor	dx,dx		; DX = 0
   136 000000F0 F7F1                <1> 	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
   137 000000F2 3D0000              <1> 	cmp	ax,0
   138 000000F5 7403                <1> 	je	.below10
   139 000000F7 E8F3FF              <1> 	call	.print_rec	; print number / 10 recursively
   140                              <1> .below10:
   141 000000FA 89D0                <1> 	mov	ax,dx		; reminder is in DX
   142 000000FC E80200              <1> 	call	print_digit	; print reminder
   143 000000FF 5A                  <1> 	pop	dx
   144 00000100 C3                  <1> 	ret
   145                              <1> 
   146                              <1> ;=========================================================================
   147                              <1> ; print_digit - print hexadecimal digit
   148                              <1> ; Input:
   149                              <1> ;	AL - bits 3...0 - digit to print (0...F)
   150                              <1> ; Output:
   151                              <1> ;	none
   152                              <1> ;-------------------------------------------------------------------------
   153                              <1> print_digit:
   154 00000101 50                  <1> 	push	ax
   155 00000102 53                  <1> 	push	bx
   156 00000103 240F                <1> 	and	al,0Fh
   157 00000105 0430                <1> 	add	al,'0'			; convert to ASCII
   158 00000107 3C39                <1> 	cmp	al,'9'			; less or equal 9?
   159 00000109 7602                <1> 	jna	.1
   160 0000010B 0407                <1> 	add	al,'A'-'9'-1		; a hex digit
   161                              <1> .1:
   162 0000010D B40E                <1> 	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
   163 0000010F B307                <1> 	mov	bl,07h			; just in case we're in graphic mode
   164 00000111 CD10                <1> 	int	10h
   165 00000113 5B                  <1> 	pop	bx
   166 00000114 58                  <1> 	pop	ax
   167 00000115 C3                  <1> 	ret
   168                              <1> 
   116                                  
   117                                  ; -----------------------------------------------------------------------		
   118                                  ; get and process the command line args
   119                                  ; -----------------------------------------------------------------------	
   120                                  get_args:
   121 00000116 BB8100                  	mov bx, args_data
   122 00000119 B90000                  	mov cx, 0
   123                                  
   124                                  	; grab 2 single-digit args
   125 0000011C E8C500                  	call skip_delim	
   126 0000011F 8A07                    	mov al, [bx]
   127 00000121 E8B400                  	call is_num
   128 00000124 7203E9DE00              	jnc print_usage		; if first arg not a number, print usage and exit
   129 00000129 A2[2D00]                	mov [port_arg], al
   130 0000012C 43                      	inc bx	
   131 0000012D 8A07                    	mov al, [bx]
   132 0000012F E8BE00                  	call test_delim
   133 00000132 7403E9D000              	jne print_usage		; if more than just 1 char, print usage and exit
   134                                  
   135 00000137 E8AA00                  	call skip_delim
   136 0000013A 8A07                    	mov al, [bx]
   137 0000013C E89900                  	call is_num
   138 0000013F 7203E9C300              	jnc print_usage		; if first arg not a number, print usage and exit
   139 00000144 A2[2E00]                	mov [baud_arg], al
   140 00000147 43                      	inc bx	
   141 00000148 8A07                    	mov al, [bx]
   142 0000014A E8A300                  	call test_delim
   143 0000014D 7403E9B500              	jne print_usage		; if more than just 1 char, print usage and exit
   144                                  
   145                                  	; process args
   146                                  	; com port
   147                                  first_arg:	
   148 00000152 A0[2D00]                	mov al, [port_arg]
   149 00000155 3C31                    	cmp al, '1'
   150 00000157 7509                    	jne .test2
   151 00000159 C706[2F00]F803          	mov [com_io], word 0x3F8	
   152 0000015F E92800                  	jmp next_arg
   153                                  .test2:	
   154 00000162 3C32                    	cmp al, '2'
   155 00000164 7509                    	jne .test3
   156 00000166 C706[2F00]F802          	mov [com_io], word 0x2F8
   157 0000016C E91B00                  	jmp next_arg
   158                                  .test3:	
   159 0000016F 3C33                    	cmp al, '3'
   160 00000171 7509                    	jne .test4
   161 00000173 C706[2F00]E803          	mov [com_io], word 0x3E8
   162 00000179 E90E00                  	jmp next_arg
   163                                  .test4:	
   164 0000017C 3C34                    	cmp al, '4'
   165 0000017E 7403E98400              	jne print_usage
   166 00000183 C706[2F00]E802          	mov [com_io], word 0x2E8
   167 00000189 90                      	nop							; filler to prevent a 1A in the code that breaks bootstrap
   168                                  	; baud
   169                                  next_arg:
   170                                  	; process args
   171 0000018A A0[2E00]                	mov al, [baud_arg]
   172 0000018D 3C31                    	cmp al, '1'
   173 0000018F 7508                    	jne .test2
   174 00000191 C606[3100]30            	mov [baud_mult], byte 0x30
   175 00000196 E93C00                  	jmp .done_args
   176                                  .test2:	
   177 00000199 3C32                    	cmp al, '2'
   178 0000019B 7508                    	jne .test3
   179 0000019D C606[3100]0C            	mov [baud_mult], byte 0x0C
   180 000001A2 E93000                  	jmp .done_args
   181                                  .test3:	
   182 000001A5 3C33                    	cmp al, '3'
   183 000001A7 7508                    	jne .test4
   184 000001A9 C606[3100]06            	mov [baud_mult], byte 0x06
   185 000001AE E92400                  	jmp .done_args
   186                                  .test4:	
   187 000001B1 3C34                    	cmp al, '4'
   188 000001B3 7508                    	jne .test5
   189 000001B5 C606[3100]03            	mov [baud_mult], byte 0x03
   190 000001BA E91800                  	jmp .done_args
   191                                  .test5:	
   192 000001BD 3C35                    	cmp al, '5'
   193 000001BF 7508                    	jne .test6
   194 000001C1 C606[3100]02            	mov [baud_mult], byte 0x02
   195 000001C6 E90C00                  	jmp .done_args
   196                                  .test6:	
   197 000001C9 3C36                    	cmp al, '6'
   198 000001CB 753A                    	jne print_usage
   199 000001CD C606[3100]01            	mov [baud_mult], byte 0x01
   200 000001D2 E90000                  	jmp .done_args		
   201                                  
   202                                  .done_args:
   203 000001D5 E944FE                  	jmp init
   204                                  
   205                                  ; set carry if the ascii digit in al is a number 1-9
   206                                  is_num:
   207 000001D8 3C31                    	cmp al, '1'
   208 000001DA 7206                    	jb .nope
   209 000001DC 3C39                    	cmp al, '9'
   210 000001DE 7702                    	ja .nope
   211 000001E0 F9                      	stc
   212 000001E1 C3                      	ret
   213                                  .nope:
   214 000001E2 F8                      	clc
   215 000001E3 C3                      	ret
   216                                  
   217                                  skip_delim:
   218 000001E4 8A07                    	mov al, [bx]
   219 000001E6 E80700                  	call test_delim
   220 000001E9 7504                    	jne .end
   221 000001EB 43                      	inc bx
   222 000001EC E9F5FF                  	jmp skip_delim
   223                                  .end:
   224 000001EF C3                      	ret
   225                                  
   226                                  ; -----------------------------------------------------------------------		
   227                                  ; Test if AL contains a DOS delimiter
   228                                  ; -----------------------------------------------------------------------
   229                                  test_delim:
   230 000001F0 3C20                    	cmp al, ' '
   231 000001F2 7412                    	je .yup
   232 000001F4 3C2C                    	cmp al, ','
   233 000001F6 740E                    	je .yup
   234 000001F8 3C09                    	cmp al, 0x09
   235 000001FA 740A                    	je .yup
   236 000001FC 3C3B                    	cmp al, ';'
   237 000001FE 7406                    	je .yup
   238 00000200 3C3D                    	cmp al, '='
   239 00000202 7402                    	je .yup
   240 00000204 3C0D                    	cmp al, 0x0D
   241                                  .yup:
   242 00000206 C3                      	ret	
   243                                  
   244                                  
   245                                  ; -----------------------------------------------------------------------		
   246                                  ; print usage text, then exit
   247                                  ; -----------------------------------------------------------------------	
   248                                  print_usage:
   249 00000207 BE[0000]                	mov si, usage_text
   250 0000020A E895FE                  	call printz
   251 0000020D E94401                  	jmp bye
   252                                  
   253                                  ; -----------------------------------------------------------------------		
   254                                  ; process the command from the buffer
   255                                  ; -----------------------------------------------------------------------	
   256                                  proc_cmd:
   257 00000210 A0[0000]                	mov al, [cmdbuf]	; get cmd
   258 00000213 3C00                    	cmp al, cmd_recv_sector
   259 00000215 747E                    	je copy_sector
   260 00000217 3C01                    	cmp al, cmd_write_track
   261 00000219 7416                    	je write_track
   262 0000021B 3C08                    	cmp al, cmd_reset
   263 0000021D 7503E98C00              	je reset_drive
   264 00000222 3CFF                    	cmp al, cmd_quit
   265 00000224 7503E92B01              	je bye
   266                                  	; unknown command
   267 00000229 B03F                    	mov al, '?'	; print ?
   268 0000022B E867FE                  	call printc
   269 0000022E E9EEFD                  	jmp get_frame
   270                                  
   271                                  ; -----------------------------------------------------------------------		
   272                                  ; cmd: 01, drive #, track #, head #, sectors to write
   273                                  ; -----------------------------------------------------------------------		
   274                                  write_track:
   275 00000231 E83A00                  	call print_track
   276 00000234 8A16[0100]              	mov dl,[cmdbuf+1]		; drive #
   277 00000238 8A2E[0200]              	mov ch,[cmdbuf+2]		; track
   278 0000023C 8A36[0300]              	mov dh,[cmdbuf+3]		; head
   279 00000240 A0[0400]                	mov al,[cmdbuf+4]		; sectors to write
   280 00000243 E88500                  	call write_sectors
   281 00000246 88E0                    	mov al, ah
   282 00000248 E8B900                  	call send_byte			; send the return code
   283 0000024B 3C00                    	cmp al, 0
   284 0000024D 7503E9CDFD              	je get_frame
   285 00000252 50                      	push ax					; print ER and the return code
   286 00000253 B045                    	mov al, 'E'
   287 00000255 E83DFE                  	call printc
   288 00000258 B052                    	mov al, 'R'
   289 0000025A E838FE                  	call printc
   290 0000025D 58                      	pop ax
   291                                  	;mov ah, al
   292 0000025E E868FE                  	call print_byte
   293 00000261 B00A                    	mov al, 0x0A
   294 00000263 E82FFE                  	call printc
   295 00000266 B00D                    	mov al, 0x0D
   296 00000268 E82AFE                  	call printc
   297 0000026B E9B1FD                  	jmp get_frame
   298                                  
   299                                  ; -----------------------------------------------------------------------
   300                                  ; prints the track info
   301                                  ; -----------------------------------------------------------------------		
   302                                  print_track:
   303                                  	; drive
   304 0000026E A0[0100]                	mov al,[cmdbuf+1]
   305 00000271 E855FE                  	call print_byte
   306 00000274 B03A                    	mov al, ':'
   307 00000276 E81CFE                  	call printc
   308                                  	; track
   309 00000279 A0[0200]                	mov al,[cmdbuf+2]	
   310 0000027C E84AFE                  	call print_byte
   311 0000027F B03A                    	mov al, ':'
   312 00000281 E811FE                  	call printc
   313                                  	; head
   314 00000284 A0[0300]                	mov al,[cmdbuf+3]	
   315 00000287 E83FFE                  	call print_byte
   316 0000028A B00A                    	mov al, 0x0A
   317 0000028C E806FE                  	call printc
   318 0000028F B00D                    	mov al, 0x0D
   319 00000291 E801FE                  	call printc
   320 00000294 C3                      	ret
   321                                  
   322                                  ; -----------------------------------------------------------------------
   323                                  ; Copies the 512 byte sector from the recv buffer to the track buffer	
   324                                  ; ----------------------------------------------------------------------		
   325                                  copy_sector:
   326 00000295 B80000                  	mov ax, 0
   327 00000298 8A26[0100]              	mov ah, [cmdbuf+1]	; sector #  (* 256 since ah)
   328 0000029C D0C4                    	rol ah, 1 				; * 2
   329                                  	; now copy from secbuf to trackbuf
   330 0000029E B90002                  	mov cx, 512
   331 000002A1 05[0802]                	add ax, trackbuf	
   332 000002A4 89C7                    	mov di, ax
   333 000002A6 BE[0800]                	mov si, secbuf			; source
   334 000002A9 F3A4                    	rep movsb
   335 000002AB E971FD                  	jmp get_frame
   336                                  
   337                                  ; -----------------------------------------------------------------------
   338                                  ; Resets the drive - makes it find track 0 again	
   339                                  ; ----------------------------------------------------------------------			
   340                                  reset_drive:
   341 000002AE B400                    	mov ah, 0
   342 000002B0 8A16[0100]              	mov dl, [cmdbuf+1]
   343 000002B4 CD13                    	int 0x13
   344 000002B6 88E0                    	mov al, ah
   345 000002B8 E84900                  	call send_byte			; send the return code
   346 000002BB C3                      	ret	
   347                                  
   348                                  
   349                                  ; -----------------------------------------------------------------------		
   350                                  ; BSD Checksum code
   351                                  ; IN:  	DS:SI = points to data to checksum
   352                                  ;		CX = length of data to checksum
   353                                  ; OUT:	BX = checksum
   354                                  ; -----------------------------------------------------------------------		
   355                                  compute_checksum:
   356 000002BC FC                          cld
   357 000002BD BB0000                      mov bx, 0
   358 000002C0 B80000                      mov ax, 0
   359                                  .loop:
   360 000002C3 AC                          lodsb
   361 000002C4 D1CB                        ror bx, 1
   362 000002C6 01C3                        add bx, ax
   363 000002C8 E2F9                    	loop .loop
   364 000002CA C3                      	ret
   365                                  
   366                                  ; -----------------------------------------------------------------------
   367                                  ; Writes a track
   368                                  ; IN:  
   369                                  ;	AL - # of sectors	
   370                                  ;	DL - drive
   371                                  ;	DH - head
   372                                  ;	CH - track
   373                                  ; ----------------------------------------------------------------------
   374                                  write_sectors:
   375 000002CB B403                    	mov ah, 3				; writing
   376 000002CD B101                    	mov cl, 1				; sector to start with
   377 000002CF BB[0802]                	mov bx, trackbuf  		;  
   378 000002D2 CD13                    	int 0x13
   379 000002D4 C3                      	ret
   380                                  
   381                                  ; -----------------------------------------------------------------------	
   382                                  ; return next serial byte in al
   383                                  ; -----------------------------------------------------------------------	
   384                                  
   385                                  recv_byte:
   386                                  	; return next serial byte in al
   387                                    	; wait for an available byte
   388 000002D5 52                       	push dx
   389 000002D6 8B16[2F00]              	mov dx, [com_io]
   390 000002DA 81C20400                	add dx, 4
   391 000002DE B002                    	mov al, 0x02
   392 000002E0 EE                      	out dx, al		; set RTS
   393                                  
   394                                  .loop:
   395 000002E1 8B16[2F00]              	mov dx, [com_io]
   396 000002E5 81C20500                	add dx, 5
   397 000002E9 EC                      	in al, dx
   398 000002EA 2401                    	and al, 0x01
   399 000002EC 3C00                    	cmp al, 0	
   400 000002EE 74F1                    	je .loop
   401                                  
   402 000002F0 8B16[2F00]              	mov dx, [com_io]
   403 000002F4 EC                      	in al, dx			; get byte
   404 000002F5 50                      	push ax
   405                                  
   406 000002F6 8B16[2F00]              	mov dx, [com_io]
   407 000002FA 81C20400                	add dx, 4
   408 000002FE B000                    	mov al, 0x00
   409 00000300 EE                      	out dx, al		; clear RTS
   410                                  	
   411 00000301 58                      	pop ax
   412 00000302 5A                      	pop dx
   413 00000303 C3                      	ret
   414                                  	
   415                                  ; -----------------------------------------------------------------------	
   416                                  ; send serial byte from AL
   417                                  ; -----------------------------------------------------------------------	
   418                                  send_byte:	
   419 00000304 52                      	push dx
   420 00000305 50                      	push ax
   421                                  	.loop:
   422 00000306 8B16[2F00]              	mov dx, [com_io]
   423 0000030A 81C20500                	add dx, 5
   424 0000030E EC                      	in al, dx
   425 0000030F 2420                    	and al, 0x20
   426 00000311 3C00                    	cmp al, 0				; transmit buffer ready?
   427 00000313 74F1                    	je .loop
   428 00000315 58                      	pop ax
   429 00000316 8B16[2F00]              	mov dx, [com_io]
   430 0000031A EE                      	out dx, al
   431 0000031B 5A                      	pop dx
   432 0000031C C3                      	ret
   433                                  	
   434                                  ; -----------------------------------------------------------------------
   435                                  ;	Setup com port
   436                                  ; -----------------------------------------------------------------------
   437                                  init_com:
   438 0000031D 8B16[2F00]              	mov dx, [com_io]
   439 00000321 81C20100                	add dx, 1			; com_io + 1
   440 00000325 B000                    	mov al, 0x00
   441 00000327 EE                      	out dx, al
   442                                  
   443 00000328 81C20200                	add dx, 2			; com_io + 2
   444 0000032C B080                    	mov al, 0x80
   445 0000032E EE                      	out dx, al
   446                                  
   447 0000032F 8B16[2F00]              	mov dx, [com_io]		; com_io
   448 00000333 A0[3100]                	mov al, [baud_mult]
   449 00000336 EE                      	out dx, al	
   450                                  
   451 00000337 81C20100                	add dx, 1				; com_io + 1
   452 0000033B B000                    	mov al, 0x00
   453 0000033D EE                      	out dx, al
   454                                  
   455 0000033E 81C20200                	add dx, 2				; com_io + 3
   456 00000342 B003                    	mov al, 0x03
   457 00000344 EE                      	out dx, al
   458                                  
   459 00000345 81EA0100                	sub dx, 1				; com_io + 2
   460 00000349 B0C7                    	mov al, 0xC7
   461 0000034B EE                      	out dx, al
   462                                  
   463 0000034C 81C20200                	add dx, 2				; com_io + 4
   464 00000350 B000                    	mov al, 0x00
   465 00000352 EE                      	out dx, al
   466                                  
   467 00000353 C3                      	ret
   468                                  
   469                                  ; -----------------------------------------------------------------------	
   470                                  ;	Exit to dos
   471                                  ; -----------------------------------------------------------------------	
   472                                  bye:
   473 00000354 B8004C                  	mov ax, 0x4c00
   474 00000357 CD21                    	int 0x21
   475                                  	
   476                                  ; -----------------------------------------------------------------------	
   477                                  ; -----------------------------------------------------------------------	
   478                                  
   479                                  section .data
   480                                    ; program data
   481 00000000 55736167653A205365-       usage_text db "Usage: See README.TXT",0
   481 00000009 6520524541444D452E-
   481 00000012 54585400           
   482 00000016 4241442046494C4520-       bad_cksum_text db "BAD FILE CHECKSUM",0
   482 0000001F 434845434B53554D00 
   483 00000028 90                        startcode db 0x90
   484 00000029 0000                      datalen dw 0x0000
   485 0000002B FFFF                      chksum dw 0xFFFF
   486 0000002D 31                        port_arg db "1"
   487 0000002E 31                        baud_arg db "1"
   488 0000002F F803                      com_io dw 0x03F8
   489 00000031 0C                        baud_mult db 0x0C
   490                                    ; !! Make sure these are at the end of the file !!
   491 00000032 AA55                      file_len dw 0x55AA
   492 00000034 AA55                      file_cksum dw 0x55AA
   493                                    
   494                                  section .bss
   495                                  	; uninitialized data
   496 00000000 ????????????????        	cmdbuf resb 8			; buffer for serial cmd
   497 00000008 <res 200h>              	secbuf resb 512			; buffer for serial sector data
   498 00000208 <res 2400h>               	trackbuf resb 9216  	; for storing 1 track (1.44mb = 18 sector tracks = 512 * 18)
