     1                                  [map symbols ssdw.map]
     2                                  
     3                                  %include "ssdw.mac"
     1                              <1> %ifndef SSDW_MAC
     2                              <1>     %define SSDW_MAC
     3                              <1>     %macro outb 2
     4                              <1>         mov dx, %1
     5                              <1>         mov al, %2
     6                              <1>         out dx, al
     7                              <1>     %endmacro
     8                              <1> 
     9                              <1>     %macro inb 1
    10                              <1>         mov dx, %1
    11                              <1>         in al, dx
    12                              <1>     %endmacro
    13                              <1> 
    14                              <1>     %macro savmain 0
    15                              <1>             push ax
    16                              <1>             push bx
    17                              <1>             push cx
    18                              <1>             push dx
    19                              <1>     %endmacro
    20                              <1> 
    21                              <1>     %macro restmain 0
    22                              <1>             pop dx
    23                              <1>             pop cx
    24                              <1>             pop bx
    25                              <1>             pop ax
    26                              <1>     %endmacro 
    27                              <1> %endif
    28                              <1> 
     4                                  
     5                                  bits 16
     6                                  cpu 8086
     7                                  
     8                                  comio 		equ 	0x3f8	; 0x3f8 = COM1,  0x2f8 = COM2
     9                                  com_mult 	equ		0x01 	; 30=2400, 0C=9600,
    10                                  							; 06=19200, 03=38400, 
    11                                  							; 02=57600, 01=115200
    12                                  
    13                                  cmd_recv_sector equ 	0x00		; cmd: 00, sector # (0-17) , NA
    14                                  cmd_write_track equ 	0x01		; cmd: 01, drive #, track #, head #, sectors to write
    15                                  cmd_reset 		equ 	0x08		; TODO cmd: 08, drive #
    16                                  cmd_quit 		equ 	0xFF		; cmd: FF, NA
    17                                  
    18                                  org 100h
    19                                  section .text 
    20                                  
    21                                  start:
    22 00000000 E8EE01                  	call init_com
    23                                  ; -----------------------------------------------------------------------		
    24                                  get_frame:
    25                                  	; wait for our frame startcode
    26 00000003 E8B901                  	call recv_byte
    27 00000006 3A06[0900]              	cmp al, [startcode]
    28 0000000A 75F7                    	jne get_frame
    29                                  
    30                                  	; next 2 bytes are the length of the cmd + data (if any)
    31 0000000C E8B001                  	call recv_byte
    32 0000000F A2[0A00]                	mov [datalen], al
    33 00000012 E8AA01                  	call recv_byte
    34 00000015 A2[0B00]                	mov [datalen + 1], al
    35 00000018 8B0E[0A00]              	mov cx, [datalen]
    36 0000001C 81F90802                	cmp cx, 0x208
    37 00000020 77E1                    	ja get_frame	; too big, something wrong, start over
    38                                  
    39                                  	; grab the data
    40 00000022 BB[0000]                	mov bx, cmdbuf
    41                                  .dataloop:
    42 00000025 E89701                  	call recv_byte
    43 00000028 8807                    	mov [bx],al
    44 0000002A 43                      	inc bx
    45 0000002B E2F8                    	loop .dataloop
    46                                  
    47                                  	; grab the checksum
    48 0000002D E88F01                  	call recv_byte
    49 00000030 A2[0C00]                	mov [chksum],al
    50 00000033 E88901                  	call recv_byte
    51 00000036 A2[0D00]                	mov [chksum+1],al	
    52                                  
    53 00000039 BE[0000]                	mov si, cmdbuf
    54 0000003C 8B0E[0A00]              	mov cx, [datalen]
    55 00000040 E86301                  	call compute_checksum
    56                                  
    57 00000043 3B1E[0C00]              	cmp bx, [chksum]
    58                                  	; if checksum match:
    59                                  	; 	send startcode + 2
    60                                  	; 	startcode XOR= 1
    61                                  	; 	process cmd
    62                                  
    63 00000047 751E                    	jne badchk
    64 00000049 B02E                    	mov al, '.'	; print period
    65 0000004B E82B00                  	call printc
    66 0000004E A0[0900]                	mov al, [startcode]
    67 00000051 0402                    	add al, 2
    68 00000053 E88801                  	call send_byte
    69 00000056 A0[0900]                	mov al, [startcode]
    70 00000059 3401                    	xor al, 1
    71 0000005B A2[0900]                	mov [startcode], al
    72 0000005E B80000                  	mov ax,0
    73 00000061 E89600                  	call proc_cmd
    74 00000064 E99CFF                  	jmp get_frame
    75                                  
    76                                  	; otherwise:
    77                                  	; 	send startcode XOR=1 + 2
    78                                  	; 	loop back and wait again
    79                                  
    80                                  badchk:	
    81 00000067 B078                    	mov al, 'x'		; print x
    82 00000069 E80D00                  	call printc
    83 0000006C A0[0900]                	mov al, [startcode]
    84 0000006F 3401                    	xor al, 1
    85 00000071 0402                    	add al, 2
    86 00000073 E86801                  	call send_byte
    87 00000076 E98AFF                  	jmp get_frame
    88                                  
    89                                  %include "print.asm"
     1                              <1> ;=========================================================================
     2                              <1> ; Pulled on 2023/2/8 from bios.asm here:
     3                              <1> ; https://github.com/skiselev/8088_bios
     4                              <1> ; Mods: 
     5                              <1> ; pull out just the print functions
     6                              <1> ; print renamed -> printz
     7                              <1> ; add printc
     8                              <1> ;-------------------------------------------------------------------------
     9                              <1> ;
    10                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    11                              <1> ;
    12                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    13                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                              <1> ;
    15                              <1> ; This program is free software: you can redistribute it and/or modify
    16                              <1> ; it under the terms of the GNU General Public License as published by
    17                              <1> ; the Free Software Foundation, either version 3 of the License, or
    18                              <1> ; (at your option) any later version.
    19                              <1> ;
    20                              <1> ; This program is distributed in the hope that it will be useful,
    21                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                              <1> ; GNU General Public License for more details.
    24                              <1> ;
    25                              <1> ; You should have received a copy of the GNU General Public License
    26                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                              <1> ;
    28                              <1> ;=========================================================================
    29                              <1> 
    30                              <1> ;=========================================================================
    31                              <1> ; print - print one char to the console
    32                              <1> ; Input:
    33                              <1> ;	AL - char to print
    34                              <1> ; Output:
    35                              <1> ;	none
    36                              <1> ;-------------------------------------------------------------------------
    37                              <1> printc:
    38 00000079 9C                  <1> 	pushf
    39 0000007A 50                  <1> 	push	ax
    40 0000007B 53                  <1> 	push	bx
    41 0000007C B40E                <1> 	mov	ah,0Eh
    42 0000007E B30F                <1> 	mov	bl,0Fh
    43 00000080 CD10                <1> 	int	10h
    44 00000082 5B                  <1> 	pop	bx
    45 00000083 58                  <1> 	pop	ax
    46 00000084 9D                  <1> 	popf
    47 00000085 C3                  <1> 	ret
    48                              <1> 
    49                              <1> ;=========================================================================
    50                              <1> ; printz - print ASCIIZ string to the console
    51                              <1> ; Input:
    52                              <1> ;	CS:SI - pointer to string to print
    53                              <1> ; Output:
    54                              <1> ;	none
    55                              <1> ;-------------------------------------------------------------------------
    56                              <1> printz:
    57 00000086 9C                  <1> 	pushf
    58 00000087 50                  <1> 	push	ax
    59 00000088 53                  <1> 	push	bx
    60 00000089 56                  <1> 	push	si
    61 0000008A 1E                  <1> 	push	ds
    62 0000008B 0E                  <1> 	push	cs
    63 0000008C 1F                  <1> 	pop	ds
    64 0000008D FC                  <1> 	cld
    65                              <1> .1:
    66 0000008E AC                  <1> 	lodsb
    67 0000008F 08C0                <1> 	or	al,al
    68 00000091 7409                <1> 	jz	.exit
    69 00000093 B40E                <1> 	mov	ah,0Eh
    70 00000095 B30F                <1> 	mov	bl,0Fh
    71 00000097 CD10                <1> 	int	10h
    72 00000099 E9F2FF              <1> 	jmp	.1
    73                              <1> .exit:
    74 0000009C 1F                  <1> 	pop	ds
    75 0000009D 5E                  <1> 	pop	si
    76 0000009E 5B                  <1> 	pop	bx
    77 0000009F 58                  <1> 	pop	ax
    78 000000A0 9D                  <1> 	popf
    79 000000A1 C3                  <1> 	ret
    80                              <1> 
    81                              <1> ;=========================================================================
    82                              <1> ; print_hex - print 16-bit number in hexadecimal
    83                              <1> ; Input:
    84                              <1> ;	AX - number to print
    85                              <1> ; Output:
    86                              <1> ;	none
    87                              <1> ;-------------------------------------------------------------------------
    88                              <1> print_hex:
    89 000000A2 86C4                <1> 	xchg	al,ah
    90 000000A4 E80600              <1> 	call	print_byte		; print the upper byte
    91 000000A7 86C4                <1> 	xchg	al,ah
    92 000000A9 E80100              <1> 	call	print_byte		; print the lower byte
    93 000000AC C3                  <1> 	ret
    94                              <1> 
    95                              <1> ;=========================================================================
    96                              <1> ; print_byte - print a byte in hexadecimal
    97                              <1> ; Input:
    98                              <1> ;	AL - byte to print
    99                              <1> ; Output:
   100                              <1> ;	none
   101                              <1> ;-------------------------------------------------------------------------
   102                              <1> print_byte:
   103 000000AD D0C0                <1> 	rol	al,1
   104 000000AF D0C0                <1> 	rol	al,1
   105 000000B1 D0C0                <1> 	rol	al,1
   106 000000B3 D0C0                <1> 	rol	al,1
   107 000000B5 E82D00              <1> 	call	print_digit
   108 000000B8 D0C0                <1> 	rol	al,1
   109 000000BA D0C0                <1> 	rol	al,1
   110 000000BC D0C0                <1> 	rol	al,1
   111 000000BE D0C0                <1> 	rol	al,1
   112 000000C0 E82200              <1> 	call	print_digit
   113 000000C3 C3                  <1> 	ret
   114                              <1> 
   115                              <1> ;=========================================================================
   116                              <1> ; print_dec - print 16-bit number in decimal
   117                              <1> ; Input:
   118                              <1> ;	AX - number to print
   119                              <1> ; Output:
   120                              <1> ;	none
   121                              <1> ;-------------------------------------------------------------------------
   122                              <1> print_dec:
   123 000000C4 50                  <1> 	push	ax
   124 000000C5 51                  <1> 	push	cx
   125 000000C6 52                  <1> 	push	dx
   126 000000C7 B90A00              <1> 	mov	cx,10		; base = 10
   127 000000CA E80400              <1> 	call	.print_rec
   128 000000CD 5A                  <1> 	pop	dx
   129 000000CE 59                  <1> 	pop	cx
   130 000000CF 58                  <1> 	pop	ax
   131 000000D0 C3                  <1> 	ret
   132                              <1> 
   133                              <1> .print_rec:			; print all digits recursively
   134 000000D1 52                  <1> 	push	dx
   135 000000D2 31D2                <1> 	xor	dx,dx		; DX = 0
   136 000000D4 F7F1                <1> 	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
   137 000000D6 3D0000              <1> 	cmp	ax,0
   138 000000D9 7403                <1> 	je	.below10
   139 000000DB E8F3FF              <1> 	call	.print_rec	; print number / 10 recursively
   140                              <1> .below10:
   141 000000DE 89D0                <1> 	mov	ax,dx		; reminder is in DX
   142 000000E0 E80200              <1> 	call	print_digit	; print reminder
   143 000000E3 5A                  <1> 	pop	dx
   144 000000E4 C3                  <1> 	ret
   145                              <1> 
   146                              <1> ;=========================================================================
   147                              <1> ; print_digit - print hexadecimal digit
   148                              <1> ; Input:
   149                              <1> ;	AL - bits 3...0 - digit to print (0...F)
   150                              <1> ; Output:
   151                              <1> ;	none
   152                              <1> ;-------------------------------------------------------------------------
   153                              <1> print_digit:
   154 000000E5 50                  <1> 	push	ax
   155 000000E6 53                  <1> 	push	bx
   156 000000E7 240F                <1> 	and	al,0Fh
   157 000000E9 0430                <1> 	add	al,'0'			; convert to ASCII
   158 000000EB 3C39                <1> 	cmp	al,'9'			; less or equal 9?
   159 000000ED 7602                <1> 	jna	.1
   160 000000EF 0407                <1> 	add	al,'A'-'9'-1		; a hex digit
   161                              <1> .1:
   162 000000F1 B40E                <1> 	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
   163 000000F3 B307                <1> 	mov	bl,07h			; just in case we're in graphic mode
   164 000000F5 CD10                <1> 	int	10h
   165 000000F7 5B                  <1> 	pop	bx
   166 000000F8 58                  <1> 	pop	ax
   167 000000F9 C3                  <1> 	ret
   168                              <1> 
    90                                  
    91                                  ; -----------------------------------------------------------------------		
    92                                  proc_cmd:
    93 000000FA A0[0000]                	mov al, [cmdbuf]	; get cmd
    94 000000FD 3C00                    	cmp al, cmd_recv_sector
    95 000000FF 747E                    	je copy_sector
    96 00000101 3C01                    	cmp al, cmd_write_track
    97 00000103 7416                    	je write_track
    98 00000105 3C08                    	cmp al, cmd_reset
    99 00000107 7503E98C00              	je reset_drive
   100 0000010C 3CFF                    	cmp al, cmd_quit
   101 0000010E 7503E90901              	je bye
   102                                  	; unknown command
   103 00000113 B03F                    	mov al, '?'	; print ?
   104 00000115 E861FF                  	call printc
   105 00000118 E9E8FE                  	jmp get_frame
   106                                  
   107                                  ; -----------------------------------------------------------------------		
   108                                  ; cmd: 01, drive #, track #, head #, sectors to write
   109                                  write_track:
   110 0000011B E83A00                  	call print_track
   111 0000011E 8A16[0100]              	mov dl,[cmdbuf+1]		; drive #
   112 00000122 8A2E[0200]              	mov ch,[cmdbuf+2]		; track
   113 00000126 8A36[0300]              	mov dh,[cmdbuf+3]		; head
   114 0000012A A0[0400]                	mov al,[cmdbuf+4]		; sectors to write
   115 0000012D E88500                  	call write_sectors
   116 00000130 88E0                    	mov al, ah
   117 00000132 E8A900                  	call send_byte			; send the return code
   118 00000135 3C00                    	cmp al, 0
   119 00000137 7503E9C7FE              	je get_frame
   120 0000013C 50                      	push ax
   121 0000013D B045                    	mov al, 'E'
   122 0000013F E837FF                  	call printc
   123 00000142 B052                    	mov al, 'R'
   124 00000144 E832FF                  	call printc
   125 00000147 58                      	pop ax
   126                                  	;mov ah, al
   127 00000148 E862FF                  	call print_byte
   128 0000014B B00A                    	mov al, 0x0A
   129 0000014D E829FF                  	call printc
   130 00000150 B00D                    	mov al, 0x0D
   131 00000152 E824FF                  	call printc
   132 00000155 E9ABFE                  	jmp get_frame
   133                                  
   134                                  ; -----------------------------------------------------------------------
   135                                  ; prints the track info
   136                                  ; -----------------------------------------------------------------------		
   137                                  print_track:
   138                                  	; drive
   139 00000158 A0[0100]                	mov al,[cmdbuf+1]
   140 0000015B E84FFF                  	call print_byte
   141 0000015E B03A                    	mov al, ':'
   142 00000160 E816FF                  	call printc
   143                                  	; track
   144 00000163 A0[0200]                	mov al,[cmdbuf+2]	
   145 00000166 E844FF                  	call print_byte
   146 00000169 B03A                    	mov al, ':'
   147 0000016B E80BFF                  	call printc
   148                                  	; head
   149 0000016E A0[0300]                	mov al,[cmdbuf+3]	
   150 00000171 E839FF                  	call print_byte
   151 00000174 B00A                    	mov al, 0x0A
   152 00000176 E800FF                  	call printc
   153 00000179 B00D                    	mov al, 0x0D
   154 0000017B E8FBFE                  	call printc
   155 0000017E C3                      	ret
   156                                  
   157                                  ; -----------------------------------------------------------------------
   158                                  ; Copies the 512 byte sector from the recv buffer to the track buffer	
   159                                  ; ----------------------------------------------------------------------		
   160                                  copy_sector:
   161 0000017F B80000                  	mov ax, 0
   162 00000182 8A26[0100]              	mov ah, [cmdbuf+1]	; sector #  (* 256 since ah)
   163 00000186 D0C4                    	rol ah, 1 				; * 2
   164                                  	; now copy from secbuf to trackbuf
   165 00000188 B90002                  	mov cx, 512
   166 0000018B 05[0802]                	add ax, trackbuf	
   167 0000018E 89C7                    	mov di, ax
   168 00000190 BE[0800]                	mov si, secbuf			; source
   169 00000193 F3A4                    	rep movsb
   170 00000195 E96BFE                  	jmp get_frame
   171                                  
   172                                  ; -----------------------------------------------------------------------
   173                                  ; Resets the drive - makes it find track 0 again	
   174                                  ; ----------------------------------------------------------------------			
   175                                  reset_drive:
   176 00000198 B400                    	mov ah, 0
   177 0000019A 8A16[0100]              	mov dl, [cmdbuf+1]
   178 0000019E CD13                    	int 0x13
   179 000001A0 88E0                    	mov al, ah
   180 000001A2 E83900                  	call send_byte			; send the return code
   181 000001A5 C3                      	ret	
   182                                  
   183                                  ; -----------------------------------------------------------------------		
   184                                  ; BSD Checksum code
   185                                  ; IN:  	DS:SI = points to data to checksum
   186                                  ;		CX = length of data to checksum
   187                                  ; OUT:	BX = checksum
   188                                  ; -----------------------------------------------------------------------		
   189                                  compute_checksum:
   190 000001A6 FC                          cld
   191 000001A7 BB0000                      mov bx, 0
   192 000001AA B80000                      mov ax, 0
   193                                  .loop:
   194 000001AD AC                          lodsb
   195 000001AE D1CB                        ror bx, 1
   196 000001B0 01C3                        add bx, ax
   197 000001B2 E2F9                    	loop .loop
   198 000001B4 C3                      	ret
   199                                  
   200                                  ; -----------------------------------------------------------------------
   201                                  ; Writes a track
   202                                  ; IN:  
   203                                  ;	AL - # of sectors	
   204                                  ;	DL - drive
   205                                  ;	DH - head
   206                                  ;	CH - track
   207                                  ; ----------------------------------------------------------------------
   208                                  write_sectors:
   209 000001B5 B403                    	mov ah, 3				; writing
   210 000001B7 B101                    	mov cl, 1				; sector to start with
   211 000001B9 BB[0802]                	mov bx, trackbuf  		;  
   212 000001BC CD13                    	int 0x13
   213 000001BE C3                      	ret
   214                                  
   215                                  ; -----------------------------------------------------------------------	
   216                                  ; return next serial byte in al
   217                                  ; -----------------------------------------------------------------------	
   218                                  
   219                                  recv_byte:
   220                                  	; return next serial byte in al
   221                                    	; wait for an available byte
   222 000001BF 52                       	push dx
   223                                  	outb comio+4,2  ; set RTS
     4 000001C0 BAFC03              <1>  mov dx, %1
     5 000001C3 B002                <1>  mov al, %2
     6 000001C5 EE                  <1>  out dx, al
   224                                  	.loop:
   225                                  	inb comio+5
    10 000001C6 BAFD03              <1>  mov dx, %1
    11 000001C9 EC                  <1>  in al, dx
   226 000001CA 2401                    	and al, 0x01
   227 000001CC 3C00                    	cmp al, 0	
   228 000001CE 74F6                    	je .loop
   229                                  	inb comio
    10 000001D0 BAF803              <1>  mov dx, %1
    11 000001D3 EC                  <1>  in al, dx
   230 000001D4 50                      	push ax
   231                                  	outb comio+4,0  ; clear RTS
     4 000001D5 BAFC03              <1>  mov dx, %1
     5 000001D8 B000                <1>  mov al, %2
     6 000001DA EE                  <1>  out dx, al
   232 000001DB 58                      	pop ax
   233 000001DC 5A                      	pop dx
   234 000001DD C3                      	ret
   235                                  	
   236                                  ; -----------------------------------------------------------------------	
   237                                  ; send serial byte from AL
   238                                  ; -----------------------------------------------------------------------	
   239                                  send_byte:	
   240 000001DE 52                      	push dx
   241 000001DF 50                      	push ax
   242                                  	.loop:
   243                                  	inb comio+5
    10 000001E0 BAFD03              <1>  mov dx, %1
    11 000001E3 EC                  <1>  in al, dx
   244 000001E4 2420                    	and al, 0x20
   245 000001E6 3C00                    	cmp al, 0				; transmit buffer ready?
   246 000001E8 74F6                    	je .loop
   247 000001EA 58                      	pop ax
   248 000001EB BAF803                  	mov dx, comio
   249 000001EE EE                      	out dx, al
   250 000001EF 5A                      	pop dx
   251 000001F0 C3                      	ret
   252                                  	
   253                                  ; -----------------------------------------------------------------------
   254                                  ;	Setup com port
   255                                  ; -----------------------------------------------------------------------
   256                                  init_com:
   257                                  	outb comio+1, 0x00
     4 000001F1 BAF903              <1>  mov dx, %1
     5 000001F4 B000                <1>  mov al, %2
     6 000001F6 EE                  <1>  out dx, al
   258                                  	outb comio+3, 0x80 
     4 000001F7 BAFB03              <1>  mov dx, %1
     5 000001FA B080                <1>  mov al, %2
     6 000001FC EE                  <1>  out dx, al
   259                                  	outb comio+0, com_mult 	; 30=2400 baud, 0C=9600, 
     4 000001FD BAF803              <1>  mov dx, %1
     5 00000200 B001                <1>  mov al, %2
     6 00000202 EE                  <1>  out dx, al
   260                                  						; 03=38400 02=57600 01=115200
   261                                  	outb comio+1, 0x00 	;                 
     4 00000203 BAF903              <1>  mov dx, %1
     5 00000206 B000                <1>  mov al, %2
     6 00000208 EE                  <1>  out dx, al
   262                                  	outb comio+3, 0x03 	; 8n1
     4 00000209 BAFB03              <1>  mov dx, %1
     5 0000020C B003                <1>  mov al, %2
     6 0000020E EE                  <1>  out dx, al
   263                                  	outb comio+2, 0xC7 
     4 0000020F BAFA03              <1>  mov dx, %1
     5 00000212 B0C7                <1>  mov al, %2
     6 00000214 EE                  <1>  out dx, al
   264                                  	outb comio+4, 0x00 	; IRQs disabled, etc
     4 00000215 BAFC03              <1>  mov dx, %1
     5 00000218 B000                <1>  mov al, %2
     6 0000021A EE                  <1>  out dx, al
   265                                  						; bit 0 = DTR, bit 1 = RTS
   266 0000021B C3                      	ret
   267                                  
   268                                  ; -----------------------------------------------------------------------	
   269                                  ;	Exit to dos
   270                                  ; -----------------------------------------------------------------------	
   271                                  bye:
   272 0000021C B8004C                  	mov ax, 0x4c00
   273 0000021F CD21                    	int 0x21
   274                                  	
   275                                  ; -----------------------------------------------------------------------	
   276                                  ; -----------------------------------------------------------------------	
   277                                  
   278                                  section .data
   279                                    ; program data
   280 00000000 303030303030303024        hexbuf db "00000000$"
   281 00000009 90                        startcode db 0x90
   282 0000000A 0000                      datalen dw 0x0000
   283 0000000C FFFF                      chksum dw 0xFFFF
   284                                    
   285                                  section .bss
   286                                  	; uninitialized data
   287 00000000 ????????????????        	cmdbuf resb 8			; buffer for serial cmd
   288 00000008 <res 200h>              	secbuf resb 512			; buffer for serial sector data
   289 00000208 <res 2400h>               	trackbuf resb 9216  	; for storing 1 track (1.44mb = 18 sector tracks = 512 * 18)
